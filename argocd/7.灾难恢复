Argo CD不直接使用任何数据库（Redis被用作缓存），所以它看起来没有任何状态。之前，我们看到了如何实现高可用性的安装，主要是通过增加每个部署的副本数量来完成的。但是，我们也有应用程序定义（如Git源集群和目标集群），以及关于如何访问Kubernetes集群或如何连接到私有Git回购或私有帮助集群的详细信息。这些东西构成了Argo CD的状态，它们保存在Kubernetes资源中——要么是本地资源，比如连接细节的秘密，要么是应用程序和应用程序约束的自定义资源。
 灾难可能会由于人工干预而发生，例如Kubernetes集群或Argo CD名称空间正在被删除，或者可能是一些云提供商出现的问题。我们也可能有要将Argo CD安装从一个集群移动到另一个集群的场景。例如，也许当前的集群是用我们不想再支持的技术创建的，比如kubeadm（https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/），现在我们想转移到云提供商管理的技术。
 你可能会出现在脑海中：“但我认为这是GitOps，所以一切都保存在Git回购中，这意味着它很容易重新创建？”首先，并不是所有的东西都被保存到Git回购中。例如，当在Argo CD中注册一个新集群时，我们必须运行一个命令，使这些详细信息不在Git中（出于安全原因，这是可以的）。其次，重新创建GitOps回购中的一切可能需要很多时间——可能有数千个应用程序、数百个集群和成千上万的Git回购。更好的选择可能是从备份中恢复到以前的所有资源，而不是从头开始重新创建所有的资源；这样做要快得多。

备份
在备份中，我们有它的配置，以及所有的配置映射和秘密，所以我们为初始安装所更改的一切都应该存在。但是，备份不会存储实际的部署或状态集。这意味着需要在恢复备份之前安装它们。自定义资源的定义也是如此——我们将有所有的应用程序和应用程序项目的实例，但我们将不会有这些自定义资源的定义。
argocd admin export  > argocd-full-backup.yaml

恢复
argocd admin import  < argocd-full-backup.yaml
现在，你应该有一个新的安装，其中包含了你在创建备份时所拥有的所有状态（应用程序、集群和Git回购）。唯一的区别是，现在Redis缓存中没有任何，所以Argo CD需要开始重新计算Git回购的所有清单，这可能会影响系统最初几分钟的性能。在那之后，一切都应该照常进行。
 在本节中，我们看到Argo CD工具很容易自动执行，从创建常规备份到在新创建的集群上恢复它们。有一个备份策略和不时地做恢复练习是很重要的。我们应该为灾难发生时做好准备，并有必要的运行手册，这样我们就可以执行相同的结果，无论是凌晨2点还是下午2点。灾难是罕见的，所以我们在日常操作中会遇到很多情况。这可能是同步的应用程序数量增加，或YAML模板工具的特定版本导致超时甚至系统无响应。为此，我们需要有一个很好的可观察性策略。我们将在下一节中探讨这一问题。